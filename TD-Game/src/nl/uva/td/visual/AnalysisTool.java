package nl.uva.td.visual;

import java.text.NumberFormat;
import java.util.List;

import nl.uva.td.ai.MCTSTacticsFinder;
import nl.uva.td.ai.quality.ActionNode;
import nl.uva.td.game.GameManager;
import nl.uva.td.game.agent.Decision;
import nl.uva.td.game.faction.Race;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author philipp
 */
public class AnalysisTool extends javax.swing.JFrame {

    private static List<ActionNode> mNodes;

    /**
     * Creates new form AnalysingTool
     */
    public AnalysisTool() {
        initComponents();

        String text = getChildTable(mNodes) + "\n";
        text += ActionNode.getActionInfo();

        jTextArea1.setText(jTextArea1.getText() + "\n" + text);
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT
     * modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jTextField1 = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        // jTextField1.setText("jTextField1");

        jTextField1.addKeyListener(new java.awt.event.KeyAdapter() {
            @Override
            public void keyReleased(final java.awt.event.KeyEvent evt) {
                jTextField1KeyReleased(evt);
            }
        });
        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(
                layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(
                        layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 1024,
                                Short.MAX_VALUE)
                                .addComponent(jTextField1, javax.swing.GroupLayout.Alignment.TRAILING))
                                .addContainerGap()));
        layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(
                javax.swing.GroupLayout.Alignment.TRAILING,
                layout.createSequentialGroup()
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE,
                        javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 686, Short.MAX_VALUE)
                        .addContainerGap()));

        pack();
    }// </editor-fold>

    private void jTextField1KeyReleased(final java.awt.event.KeyEvent evt) {
        if (jTextField1.getText().length() == 0) {
            String text = getChildTable(mNodes);

            jTextArea1.setText(jTextArea1.getText() + "\n\n" + text);
            return;
        }

        if (evt.getKeyChar() != ' ') {
            return;
        }

        try {
            String arg = jTextField1.getText();
            Short nextAction = Short.parseShort(arg.substring(0, arg.indexOf(MCTSTacticsFinder.SEPERATOR)));
            String leftoverArgument = arg.substring(arg.indexOf(MCTSTacticsFinder.SEPERATOR) + 1);

            for (ActionNode node : mNodes) {
                if (node.action == nextAction) {
                    ActionNode foundNode = node;
                    if (leftoverArgument.length() != 0) {
                        foundNode = MCTSTacticsFinder.getNode(node, leftoverArgument);
                    }

                    String text = "";
                    ActionNode tmp = foundNode;
                    while (tmp != null) {
                        text += new Decision(tmp.action, Race.getRaceForType((tmp.isHuman ? Race.Type.HUMAN
                                : Race.Type.ALIEN))) + "<-";
                        tmp = tmp.parent;
                    }
                    text += "\n" + foundNode + "\n\n";

                    text += getChildTable(foundNode.mChildren);
                    jTextArea1.setText(jTextArea1.getText() + "\n\n" + text);
                    break;
                }
            }
        } catch (Exception x) {
            x.printStackTrace();
        }
    }

    private String getChildTable(final List<ActionNode> children) {
        ActionNode[] sorting = new ActionNode[GameManager.TOTAL_ACTIONS];
        for (ActionNode node : children) {
            sorting[node.action] = node;
        }

        String text = "";
        int totalWin = 0;
        int totalLose = 0;
        int totalDraw = 0;
        for (int i = 0; i < 4; ++i) {
            if (sorting[i] == null) {
                continue;
            }
            text += sorting[i].toString() + "\n";

            totalWin += sorting[i].winCounter;
            totalDraw += sorting[i].drawCounter;
            totalLose += sorting[i].loseCounter;
        }

        text += "\n";
        for (int towerType = 0; towerType < 3; ++towerType) {
            for (int towerPos = 0; towerPos < 5; ++towerPos) {
                int i = 4 + towerType + towerPos * 3;
                if (sorting[i] == null) {
                    continue;
                }
                text += sorting[i].toString() + "\n";

                totalWin += sorting[i].winCounter;
                totalDraw += sorting[i].drawCounter;
                totalLose += sorting[i].loseCounter;
            }
            text += "\n";
        }

        double total = totalWin + totalDraw + totalLose;
        final NumberFormat form = NumberFormat.getPercentInstance();
        text += "                                       Avg. Win: " + form.format(totalWin / total) + " Avg. Draw: "
                + form.format(totalDraw / total) + " Avg. Lose: " + form.format(totalLose / total) + "\n";

        return text;
    }

    /**
     * @param args
     *            the command line arguments
     */
    public static void main(final String args[]) {

        mNodes = MCTSTacticsFinder.readNodes();
        new AnalysisTool().setVisible(true);
    }

    // Variables declaration - do not modify
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration
}
